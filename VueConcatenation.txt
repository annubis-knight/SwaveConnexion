##########
layout/Container.vue
##########
<template>
  <!--
    Composant Container - Wrapper responsive

    Description : Container avec max-width responsive et padding

    Structure:
    ┌────────────────────────────────────┐
    │ ←─ padding-x                    ─→ │
    │  ┌──────────────────────────┐     │
    │  │   max-w-{size} mx-auto   │     │
    │  │   Content here           │     │
    │  └──────────────────────────┘     │
    └────────────────────────────────────┘

    Input (Props) :
      - size : 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'full' (défaut: 'lg')
      - padding : boolean (défaut: true) - Active le padding horizontal

    Output (Events) :
      Aucun

    Slots :
      - default : Contenu du container

    @dev Tailwind utilities UNIQUEMENT (pas de CSS scoped)
    @dev Sizes: sm=640px, md=768px, lg=1024px, xl=1280px, 2xl=1536px, full=100%
  -->
  <div :class="containerClass">
    <slot />
  </div>
</template>

<script setup lang="ts">
/**
 * CONTAINER COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT
 * @dev max-width responsive avec mx-auto pour centrer
 * @dev padding optionnel (px-6 md:px-8)
 */

// Props
interface Props {
  size?: 'sm' | 'md' | 'lg' | 'xl' | '2xl' | 'full';
  padding?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  size: 'full',
  padding: true,
});

// Computed classes (Tailwind utilities)
const containerClass = computed(() => {
  const sizeClasses = {
    sm: 'max-w-sm',      // 640px
    md: 'max-w-md',      // 768px
    lg: 'max-w-lg',      // 1024px
    xl: 'max-w-xl',      // 1280px
    '2xl': 'max-w-2xl',  // 1536px
    full: 'max-w-full',  // 100%
  };

  return [
    'w-full',
    'container-center',  // Custom class pour margin: 0 auto (au lieu de mx-auto qui utilise margin-inline)
    sizeClasses[props.size],
    props.padding && 'px-6 md:px-8',
  ].filter(Boolean).join(' ');
});
</script>

<style scoped>
/**
 * CONTAINER STYLES
 *
 * @dev Custom class pour centrage horizontal traditionnel
 * @dev Tailwind v4 mx-auto utilise margin-inline au lieu de margin-left/right
 */

.container-center {
  margin-left: auto;
  margin-right: auto;
}
</style>

##########
layout/Footer.vue
##########
<template>
  <!--
    Composant Footer - Pied de page

    Description : Pied de page avec grid 3 colonnes et copyright

    Props :
      - Aucune

    Slots :
      - company : Colonne entreprise
      - links : Colonne liens
      - social : Colonne réseaux sociaux

    @dev Tailwind utilities uniquement (NO CSS natif scoped)
  -->
  <footer class="bg-gray-900 text-gray-300 py-12 mt-auto">
    <div class="container mx-auto px-6">
      <!-- Grid 3 colonnes -->
      <div class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-8">
        <!-- Colonne 1 : Entreprise -->
        <div>
          <slot name="company">
            <div class="flex items-center gap-3 mb-4">
              <div class="w-10 h-10 bg-gradient-to-br from-blue-600 to-blue-800 rounded-lg flex items-center justify-center">
                <span class="text-white font-bold text-xl">S</span>
              </div>
              <span class="text-xl font-bold text-white">SwaveConnexion</span>
            </div>
            <p class="text-sm text-gray-400 leading-relaxed">
              Design system minimaliste et moderne pour applications web performantes.
            </p>
          </slot>
        </div>

        <!-- Colonne 2 : Liens -->
        <div>
          <slot name="links">
            <h4 class="text-white font-semibold mb-4">Liens rapides</h4>
            <ul class="space-y-2">
              <li><a href="#" class="text-gray-400 hover:text-blue-400 transition-colors text-sm">Documentation</a></li>
              <li><a href="#" class="text-gray-400 hover:text-blue-400 transition-colors text-sm">Composants</a></li>
              <li><a href="#" class="text-gray-400 hover:text-blue-400 transition-colors text-sm">GitHub</a></li>
              <li><a href="#" class="text-gray-400 hover:text-blue-400 transition-colors text-sm">Licence</a></li>
            </ul>
          </slot>
        </div>

        <!-- Colonne 3 : Réseaux sociaux -->
        <div>
          <slot name="social">
            <h4 class="text-white font-semibold mb-4">Suivez-nous</h4>
            <div class="flex gap-4">
              <a href="#" class="w-10 h-10 bg-gray-800 hover:bg-blue-600 rounded-lg flex items-center justify-center transition-colors">
                <span class="text-white text-sm font-bold">GH</span>
              </a>
              <a href="#" class="w-10 h-10 bg-gray-800 hover:bg-blue-400 rounded-lg flex items-center justify-center transition-colors">
                <span class="text-white text-sm font-bold">TW</span>
              </a>
              <a href="#" class="w-10 h-10 bg-gray-800 hover:bg-blue-700 rounded-lg flex items-center justify-center transition-colors">
                <span class="text-white text-sm font-bold">LI</span>
              </a>
            </div>
          </slot>
        </div>
      </div>

      <!-- Copyright -->
      <div class="border-t border-gray-800 pt-8">
        <p class="text-center text-sm text-gray-500">
          © {{ new Date().getFullYear() }} SwaveConnexion. Tous droits réservés.
        </p>
      </div>
    </div>
  </footer>
</template>

<script setup lang="ts">
/**
 * FOOTER COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT (NO CSS natif)
 * @dev Grid responsive (grid-cols-1 md:grid-cols-3)
 */
</script>

##########
layout/Grid.vue
##########
<template>
  <!--
    Composant Grid - Système de grille configurable

    Description : Grille responsive avec colonnes configurables

    Structure:
    ┌──────────┬──────────┬──────────┐
    │  Col 1   │  Col 2   │  Col 3   │
    │          │          │          │
    ├──────────┼──────────┼──────────┤
    │  Col 4   │  Col 5   │  Col 6   │
    └──────────┴──────────┴──────────┘

    Input (Props) :
      - cols : 1-12 (défaut: 3) - Nombre de colonnes desktop
      - gap : 'sm' | 'md' | 'lg' | 'xl' (défaut: 'md') - Espacement entre items
      - responsive : object { sm?: number, md?: number, lg?: number } - Colonnes par breakpoint

    Output (Events) :
      Aucun

    Slots :
      - default : Items de la grille

    @dev Tailwind utilities UNIQUEMENT (pas de CSS scoped)
    @dev Responsive: mobile 1 col → tablet responsive.md → desktop cols
  -->
  <div :class="gridClass">
    <slot />
  </div>
</template>

<script setup lang="ts">
/**
 * GRID COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT
 * @dev grid grid-cols-{n} avec gap configurable
 * @dev Responsive natif avec breakpoints Tailwind
 */

// Props
interface Props {
  cols?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12;
  gap?: 'sm' | 'md' | 'lg' | 'xl';
  responsive?: {
    sm?: number;
    md?: number;
    lg?: number;
  };
}

const props = withDefaults(defineProps<Props>(), {
  cols: 3,
  gap: 'md',
});

// Computed classes (Tailwind utilities)
const gridClass = computed(() => {
  const gapClasses = {
    sm: 'gap-4',   // 16px
    md: 'gap-6',   // 24px
    lg: 'gap-8',   // 32px
    xl: 'gap-12',  // 48px
  };

  // Mapping statique pour Tailwind v4 (safelist n'existe plus en v4)
  const colsClassMap: Record<number, string> = {
    1: 'grid-cols-1',
    2: 'grid-cols-2',
    3: 'grid-cols-3',
    4: 'grid-cols-4',
    5: 'grid-cols-5',
    6: 'grid-cols-6',
    7: 'grid-cols-7',
    8: 'grid-cols-8',
    9: 'grid-cols-9',
    10: 'grid-cols-10',
    11: 'grid-cols-11',
    12: 'grid-cols-12',
  };

  const colsClass = colsClassMap[props.cols];

  // Responsive columns avec mapping statique
  const smColsMap: Record<number, string> = {
    1: 'sm:grid-cols-1',
    2: 'sm:grid-cols-2',
    3: 'sm:grid-cols-3',
    4: 'sm:grid-cols-4',
  };

  const mdColsMap: Record<number, string> = {
    1: 'md:grid-cols-1',
    2: 'md:grid-cols-2',
    3: 'md:grid-cols-3',
    4: 'md:grid-cols-4',
  };

  const lgColsMap: Record<number, string> = {
    1: 'lg:grid-cols-1',
    2: 'lg:grid-cols-2',
    3: 'lg:grid-cols-3',
    4: 'lg:grid-cols-4',
    5: 'lg:grid-cols-5',
    6: 'lg:grid-cols-6',
    12: 'lg:grid-cols-12',
  };

  const responsiveClasses = [];
  if (props.responsive?.sm && smColsMap[props.responsive.sm]) {
    responsiveClasses.push(smColsMap[props.responsive.sm]);
  }
  if (props.responsive?.md && mdColsMap[props.responsive.md]) {
    responsiveClasses.push(mdColsMap[props.responsive.md]);
  }
  if (props.responsive?.lg && lgColsMap[props.responsive.lg]) {
    responsiveClasses.push(lgColsMap[props.responsive.lg]);
  }

  return [
    'grid',
    colsClass,
    ...responsiveClasses,
    gapClasses[props.gap],
  ].filter(Boolean).join(' ');
});
</script>

##########
layout/Header.vue
##########
<template>
  <!--
    Composant Header - Navigation principale

    Description : En-tête sticky avec logo et navigation responsive

    Props :
      - Aucune (configuration statique pour l'instant)

    Slots :
      - default : Remplace les liens de navigation

    @dev Tailwind utilities uniquement (NO CSS natif scoped)
    @dev Phase 11: Dark mode toggle
    @dev Phase 12: Theme selector
  -->
  <header class="sticky top-0 z-50 bg-white dark:bg-neutral-light border-b border-gray-200 dark:border-neutral-medium shadow-sm">
    <div class="container mx-auto px-6 py-4">
      <div class="flex items-center justify-between">
        <!-- Logo -->
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 bg-gradient-to-br from-blue-600 to-blue-800 rounded-lg flex items-center justify-center">
            <span class="text-white font-bold text-xl">S</span>
          </div>
          <span class="text-xl font-bold text-gray-900 dark:text-neutral-black">SwaveConnexion</span>
        </div>

        <!-- Navigation Desktop -->
        <nav class="hidden md:flex items-center gap-6">
          <slot>
            <a href="/" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium">Accueil</a>
            <a href="/design-system" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium">Design System</a>
            <a href="/design-system/layouts" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium">Layouts</a>
          </slot>

          <!-- Theme Selector -->
          <select
            v-model="selectedTheme"
            @change="handleThemeChange"
            class="px-3 py-1.5 text-sm border border-gray-300 dark:border-neutral-medium rounded-md bg-white dark:bg-neutral-medium text-gray-900 dark:text-neutral-black focus:outline-none focus:ring-2 focus:ring-blue-500"
            aria-label="Choisir un thème"
          >
            <option
              v-for="theme in availableThemes"
              :key="theme.value"
              :value="theme.value"
            >
              {{ theme.label }}
            </option>
          </select>

          <!-- Dark Mode Toggle -->
          <ClientOnly>
            <button
              @click="toggleDark"
              class="p-2 text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors rounded-lg hover:bg-gray-100 dark:hover:bg-neutral-medium"
              :aria-label="isDark ? 'Activer le mode clair' : 'Activer le mode sombre'"
            >
              <!-- Sun Icon (Light Mode) -->
              <svg v-if="isDark" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
              <!-- Moon Icon (Dark Mode) -->
              <svg v-else class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
              </svg>
            </button>
          </ClientOnly>
        </nav>

        <!-- Bouton Menu Mobile -->
        <button
          class="md:hidden p-2 text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors"
          @click="toggleMenu"
          aria-label="Toggle menu"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
          </svg>
        </button>
      </div>

      <!-- Navigation Mobile -->
      <Transition
        enter-active-class="transition-all duration-200"
        enter-from-class="opacity-0 -translate-y-2"
        enter-to-class="opacity-100 translate-y-0"
        leave-active-class="transition-all duration-200"
        leave-from-class="opacity-100 translate-y-0"
        leave-to-class="opacity-0 -translate-y-2"
      >
        <nav v-if="isMenuOpen" class="md:hidden mt-4 pb-4 border-t border-gray-200 dark:border-neutral-medium pt-4">
          <div class="flex flex-col gap-3">
            <a href="/" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium py-2">Accueil</a>
            <a href="/design-system" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium py-2">Design System</a>
            <a href="/design-system/layouts" class="text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium py-2">Layouts</a>

            <!-- Theme Selector Mobile -->
            <div class="py-2">
              <label class="text-sm font-medium text-gray-700 dark:text-neutral-dark mb-2 block">Thème:</label>
              <select
                v-model="selectedTheme"
                @change="handleThemeChange"
                class="w-full px-3 py-2 border border-gray-300 dark:border-neutral-medium rounded-md bg-white dark:bg-neutral-medium text-gray-900 dark:text-neutral-black focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                <option
                  v-for="theme in availableThemes"
                  :key="theme.value"
                  :value="theme.value"
                >
                  {{ theme.label }}
                </option>
              </select>
            </div>

            <!-- Dark Mode Toggle Mobile -->
            <button
              @click="toggleDark"
              class="flex items-center gap-3 text-gray-700 dark:text-neutral-dark hover:text-blue-600 transition-colors font-medium py-2"
            >
              <svg v-if="isDark" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
              </svg>
              <svg v-else class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
              </svg>
              <span>{{ isDark ? 'Mode Clair' : 'Mode Sombre' }}</span>
            </button>
          </div>
        </nav>
      </Transition>
    </div>
  </header>
</template>

<script setup lang="ts">
/**
 * HEADER COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT (NO CSS natif)
 * @dev Responsive avec breakpoints (md:hidden, md:flex)
 * @dev Phase 11: Dark mode toggle
 * @dev Phase 12: Theme selector dropdown
 */

const isMenuOpen = ref(false);

const toggleMenu = () => {
  isMenuOpen.value = !isMenuOpen.value;
};

// Theme management (PRD v2.0 - Phase 1)
const { isDark, setColorMode, currentTheme, setTheme, availableThemes } = useThemeManager();

// Local state for select binding
const selectedTheme = ref(currentTheme.value);

// Note: initTheme() appelé automatiquement via plugin theme.client.ts
// Pas besoin de onMounted() ici

// Watch currentTheme changes
watch(currentTheme, (newTheme) => {
  selectedTheme.value = newTheme;
});

// Toggle dark mode
const toggleDark = () => {
  const newMode = isDark.value ? 'light' : 'dark';
  setColorMode(newMode);
};

// Handle theme change from select
const handleThemeChange = () => {
  setTheme(selectedTheme.value);
};
</script>

##########
layout/Sidebar.vue
##########
<template>
  <!--
    Composant Sidebar - Navigation latérale

    Description : Barre latérale collapsible pour navigation secondaire

    Props :
      - isOpen : boolean (contrôle l'état ouvert/fermé)
      - position : 'left' | 'right' (position de la sidebar)

    Events :
      - close : Émis lors de la fermeture

    Slots :
      - default : Contenu de la sidebar

    @dev Tailwind utilities uniquement (NO CSS natif scoped)
  -->
  <Transition
    enter-active-class="transition-all duration-300"
    enter-from-class="opacity-0"
    enter-to-class="opacity-100"
    leave-active-class="transition-all duration-300"
    leave-from-class="opacity-100"
    leave-to-class="opacity-0"
  >
    <div
      v-if="isOpen"
      class="fixed inset-0 bg-black/50 z-40"
      @click="emit('close')"
    />
  </Transition>

  <Transition
    enter-active-class="transition-transform duration-300"
    :enter-from-class="position === 'left' ? '-translate-x-full' : 'translate-x-full'"
    enter-to-class="translate-x-0"
    leave-active-class="transition-transform duration-300"
    leave-from-class="translate-x-0"
    :leave-to-class="position === 'left' ? '-translate-x-full' : 'translate-x-full'"
  >
    <aside
      v-if="isOpen"
      :class="[
        'fixed top-0 h-full bg-white shadow-2xl z-50 w-80 overflow-y-auto',
        position === 'left' ? 'left-0' : 'right-0'
      ]"
    >
      <!-- Header avec bouton fermer -->
      <div class="flex items-center justify-between p-6 border-b border-gray-200">
        <h3 class="text-xl font-bold text-gray-900">Navigation</h3>
        <button
          @click="emit('close')"
          class="p-2 text-gray-500 hover:text-gray-900 hover:bg-gray-100 rounded-lg transition-colors"
          aria-label="Close sidebar"
        >
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>

      <!-- Contenu -->
      <div class="p-6">
        <slot>
          <nav class="flex flex-col gap-2">
            <a href="#" class="px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors font-medium">
              Accueil
            </a>
            <a href="#" class="px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors font-medium">
              Composants
            </a>
            <a href="#" class="px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors font-medium">
              Documentation
            </a>
            <a href="#" class="px-4 py-3 text-gray-700 hover:bg-blue-50 hover:text-blue-600 rounded-lg transition-colors font-medium">
              À propos
            </a>
          </nav>
        </slot>
      </div>
    </aside>
  </Transition>
</template>

<script setup lang="ts">
/**
 * SIDEBAR COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT (NO CSS natif)
 * @dev Position dynamique (left/right)
 * @dev Transitions Tailwind (duration-300, translate-x-*)
 */

interface Props {
  isOpen: boolean;
  position?: 'left' | 'right';
}

const props = withDefaults(defineProps<Props>(), {
  position: 'left',
});

interface Emits {
  close: [];
}

const emit = defineEmits<Emits>();
</script>

##########
layout/SplitPane.vue
##########
<template>
  <!--
    Composant SplitPane - Panneau divisé (sidebar + main)

    Description : Layout avec sidebar et zone principale

    Structure:
    ┌─────────┬─────────────────────┐
    │         │                     │
    │ Sidebar │     Main Content    │
    │  (col)  │     (12 - col)      │
    │         │                     │
    └─────────┴─────────────────────┘
    ← col-span → ← col-span-(12-col) →

    Input (Props) :
      - leftWidth : 1-11 (défaut: 3) - Largeur sidebar en colonnes sur 12
      - gap : 'none' | 'sm' | 'md' | 'lg' | 'xl' (défaut: 'md')
      - collapsible : boolean (défaut: false) - Sidebar collapsible sur mobile
      - fullHeight : boolean (défaut: false) - min-h-screen

    Output (Events) :
      Aucun

    Slots :
      - left : Contenu sidebar (requis)
      - right : Contenu principal (requis)

    @dev Tailwind utilities UNIQUEMENT (pas de CSS scoped)
    @dev grid grid-cols-12 avec col-span-{n}
    @dev Responsive: mobile stack vertical, desktop side-by-side
  -->
  <div :class="splitPaneClass">
    <div :class="leftPaneClass">
      <slot name="left" />
    </div>
    <div :class="rightPaneClass">
      <slot name="right" />
    </div>
  </div>
</template>

<script setup lang="ts">
/**
 * SPLIT PANE COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT
 * @dev grid grid-cols-12 avec col-span-{n}
 * @dev Responsive: mobile stack, desktop split
 */

// Props
interface Props {
  leftWidth?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11;
  gap?: 'none' | 'sm' | 'md' | 'lg' | 'xl';
  collapsible?: boolean;
  fullHeight?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  leftWidth: 3,
  gap: 'md',
  collapsible: false,
  fullHeight: false,
});

// Computed classes (Tailwind utilities)
const splitPaneClass = computed(() => {
  const gapClasses = {
    none: 'gap-0',
    sm: 'gap-4',   // 16px
    md: 'gap-6',   // 24px
    lg: 'gap-8',   // 32px
    xl: 'gap-12',  // 48px
  };

  return [
    'grid',
    'grid-cols-1',           // Mobile: stack vertical
    'lg:grid-cols-12',       // Desktop: 12 colonnes
    gapClasses[props.gap],
    props.fullHeight && 'min-h-screen',
  ].filter(Boolean).join(' ');
});

// Left pane (sidebar)
const leftPaneClass = computed(() => {
  // Map leftWidth to col-span classes
  const colSpanClasses = {
    1: 'lg:col-span-1',
    2: 'lg:col-span-2',
    3: 'lg:col-span-3',
    4: 'lg:col-span-4',
    5: 'lg:col-span-5',
    6: 'lg:col-span-6',
    7: 'lg:col-span-7',
    8: 'lg:col-span-8',
    9: 'lg:col-span-9',
    10: 'lg:col-span-10',
    11: 'lg:col-span-11',
  };

  return [
    'w-full',
    colSpanClasses[props.leftWidth],
    props.collapsible && 'lg:block hidden',  // Hidden on mobile if collapsible
  ].filter(Boolean).join(' ');
});

// Right pane (main content)
const rightPaneClass = computed(() => {
  // Calculate remaining columns (12 - leftWidth)
  const rightWidth = 12 - props.leftWidth;

  const colSpanClasses = {
    1: 'lg:col-span-1',
    2: 'lg:col-span-2',
    3: 'lg:col-span-3',
    4: 'lg:col-span-4',
    5: 'lg:col-span-5',
    6: 'lg:col-span-6',
    7: 'lg:col-span-7',
    8: 'lg:col-span-8',
    9: 'lg:col-span-9',
    10: 'lg:col-span-10',
    11: 'lg:col-span-11',
  };

  return [
    'w-full',
    colSpanClasses[rightWidth as keyof typeof colSpanClasses],
  ].filter(Boolean).join(' ');
});
</script>

##########
layout/Stack.vue
##########
<template>
  <!--
    Composant Stack - Empilement vertical ou horizontal

    Description : Conteneur flex pour empiler des éléments avec espacement

    Structure (Vertical):
    ┌──────────────┐
    │   Item 1     │
    ├──────────────┤ ← gap
    │   Item 2     │
    ├──────────────┤ ← gap
    │   Item 3     │
    └──────────────┘

    Structure (Horizontal):
    ┌────┬───┬────┬───┬────┐
    │ 1  │ ↕ │ 2  │ ↕ │ 3  │
    └────┴─gap─┴────┴─gap─┴────┘

    Input (Props) :
      - direction : 'vertical' | 'horizontal' (défaut: 'vertical')
      - gap : 'none' | 'xs' | 'sm' | 'md' | 'lg' | 'xl' (défaut: 'md')
      - align : 'start' | 'center' | 'end' | 'stretch' (défaut: 'stretch')
      - justify : 'start' | 'center' | 'end' | 'between' | 'around' (défaut: 'start')

    Output (Events) :
      Aucun

    Slots :
      - default : Items à empiler

    @dev Tailwind utilities UNIQUEMENT (pas de CSS scoped)
    @dev flex avec flex-col (vertical) ou flex-row (horizontal)
    @dev Gap responsive : gap-{size}
  -->
  <div :class="stackClass">
    <slot />
  </div>
</template>

<script setup lang="ts">
/**
 * STACK COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT
 * @dev flex flex-col (vertical) ou flex-row (horizontal)
 * @dev Gap configurable avec classes utilitaires
 */

// Props
interface Props {
  direction?: 'vertical' | 'horizontal';
  gap?: 'none' | 'xs' | 'sm' | 'md' | 'lg' | 'xl';
  align?: 'start' | 'center' | 'end' | 'stretch';
  justify?: 'start' | 'center' | 'end' | 'between' | 'around';
}

const props = withDefaults(defineProps<Props>(), {
  direction: 'vertical',
  gap: 'md',
  align: 'stretch',
  justify: 'start',
});

// Computed classes (Tailwind utilities)
const stackClass = computed(() => {
  const gapClasses = {
    none: 'gap-0',
    xs: 'gap-2',   // 8px
    sm: 'gap-4',   // 16px
    md: 'gap-6',   // 24px
    lg: 'gap-8',   // 32px
    xl: 'gap-12',  // 48px
  };

  const alignClasses = {
    start: 'items-start',
    center: 'items-center',
    end: 'items-end',
    stretch: 'items-stretch',
  };

  const justifyClasses = {
    start: 'justify-start',
    center: 'justify-center',
    end: 'justify-end',
    between: 'justify-between',
    around: 'justify-around',
  };

  const directionClass = props.direction === 'vertical' ? 'flex-col' : 'flex-row';

  return [
    'flex',
    directionClass,
    gapClasses[props.gap],
    alignClasses[props.align],
    justifyClasses[props.justify],
  ].filter(Boolean).join(' ');
});
</script>

##########
sections/CTA.vue
##########
<template>
  <!--
    Composant CTA - Call To Action

    Description : Section d'appel à l'action avec titre, description et boutons

    Structure:
    ┌────────────────────────────────────────────┐
    │     Container (max-width, centered)        │
    │  ┌──────────────────────────────────────┐  │
    │  │          Titre Principal            │  │
    │  │          Sous-titre/Desc            │  │
    │  │   ┌────────┐      ┌────────┐       │  │
    │  │   │ Button │      │ Button │       │  │
    │  │   │Primary │      │Secondary│      │  │
    │  │   └────────┘      └────────┘       │  │
    │  └──────────────────────────────────────┘  │
    └────────────────────────────────────────────┘

    Input (Props) :
      - title : string (requis) - Titre principal
      - description : string (optionnel) - Description/sous-titre
      - primaryText : string (défaut: "Commencer") - Texte bouton principal
      - secondaryText : string (optionnel) - Texte bouton secondaire
      - variant : 'primary' | 'gradient' (défaut: 'primary') - Style de fond
      - centered : boolean (défaut: true) - Centrer le contenu

    Output (Events) :
      - primary-click : Émis lors du clic sur bouton principal
      - secondary-click : Émis lors du clic sur bouton secondaire

    Slots :
      Aucun (données via props)

    @dev Utilise LayoutContainer et LayoutStack de Phase 9
    @dev Tailwind utilities pour styling
    @dev Variantes: fond primary ou gradient
  -->
  <section :class="sectionClass">
    <LayoutContainer size="xl" :padding="true">
      <LayoutStack
        direction="vertical"
        gap="lg"
        :align="centered ? 'center' : 'start'"
        justify="center"
      >
        <!-- Title -->
        <h2 :class="titleClass">
          {{ title }}
        </h2>

        <!-- Description -->
        <p v-if="description" :class="descriptionClass">
          {{ description }}
        </p>

        <!-- Buttons -->
        <LayoutStack
          direction="horizontal"
          gap="md"
          align="center"
          :justify="centered ? 'center' : 'start'"
        >
          <!-- Primary Button -->
          <Button
            variant="primary"
            size="lg"
            @click="handlePrimaryClick"
          >
            {{ primaryText }}
          </Button>

          <!-- Secondary Button (optional) -->
          <Button
            v-if="secondaryText"
            :variant="variant === 'gradient' ? 'outline-light' : 'outline'"
            size="lg"
            @click="handleSecondaryClick"
          >
            {{ secondaryText }}
          </Button>
        </LayoutStack>
      </LayoutStack>
    </LayoutContainer>
  </section>
</template>

<script setup lang="ts">
/**
 * CTA COMPONENT (PHASE 10)
 *
 * @dev Utilise Container + Stack de Phase 9
 * @dev Tailwind utilities pour styling
 * @dev Variantes: fond primary ou gradient
 * @dev Buttons avec events personnalisés
 */

// Props
interface Props {
  title: string;
  description?: string;
  primaryText?: string;
  secondaryText?: string;
  variant?: 'primary' | 'gradient';
  centered?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  primaryText: 'Commencer',
  variant: 'primary',
  centered: true,
});

// Events
interface Emits {
  'primary-click': [];
  'secondary-click': [];
}

const emit = defineEmits<Emits>();

// Computed classes
const sectionClass = computed(() => {
  const baseClasses = 'py-20';

  const variantClasses = {
    primary: 'bg-primary',
    gradient: 'bg-gradient-to-r from-primary via-primary-dark to-accent-dark',
    // WCAG AA: Gradient ajusté pour maintenir contraste ≥4.5:1 avec texte blanc
  };

  return [
    baseClasses,
    variantClasses[props.variant],
  ].join(' ');
});

const titleClass = computed(() => {
  return [
    'text-4xl md:text-5xl font-bold text-white',
    props.centered ? 'text-center' : 'text-left',
  ].join(' ');
});

const descriptionClass = computed(() => {
  return [
    'text-xl text-white/90 max-w-2xl',
    props.centered ? 'text-center mx-auto' : 'text-left',
  ].join(' ');
});

// Event handlers
const handlePrimaryClick = () => {
  emit('primary-click');
};

const handleSecondaryClick = () => {
  emit('secondary-click');
};
</script>

##########
sections/FeaturesGrid.vue
##########
<template>
  <!--
    Composant FeaturesGrid - Grille de fonctionnalités/features

    Description : Section présentant des features sous forme de grille avec icônes

    Structure:
    ┌──────────────────────────────────────────────┐
    │         Container (max-width)                │
    │  ┌────────────────────────────────────────┐  │
    │  │           Titre + Sous-titre          │  │
    │  └────────────────────────────────────────┘  │
    │  ┌──────┬──────┬──────┐                     │
    │  │ Icon │ Icon │ Icon │                     │
    │  │Title │Title │Title │  Grid responsive    │
    │  │Desc  │Desc  │Desc  │                     │
    │  ├──────┼──────┼──────┤                     │
    │  │ Icon │ Icon │ Icon │                     │
    │  └──────┴──────┴──────┘                     │
    └──────────────────────────────────────────────┘

    Input (Props) :
      - title : string (requis) - Titre principal
      - subtitle : string (optionnel) - Sous-titre
      - features : Feature[] (requis) - Liste des features
      - cols : 2 | 3 | 4 (défaut: 3) - Nombre de colonnes desktop

    Interface Feature :
      - icon : string - Emoji ou texte icône
      - title : string - Titre de la feature
      - description : string - Description courte

    Output (Events) :
      Aucun

    Slots :
      Aucun (données via props)

    @dev Utilise LayoutContainer et LayoutGrid de Phase 9
    @dev Tailwind utilities pour styling
    @dev Responsive: mobile 1 col → tablet 2 → desktop cols
  -->
  <section class="py-16 bg-[var(--bg-subtle)]">
    <LayoutContainer size="xl" :padding="true">
      <!-- Header -->
      <div class="text-center mb-12">
        <h2 class="mb-4">{{ title }}</h2>
        <p v-if="subtitle">
          {{ subtitle }}
        </p>
      </div>

      <!-- Features Grid -->
      <LayoutGrid
        :cols="cols"
        gap="lg"
        :responsive="{ sm: 1, md: 2, lg: cols }"
      >
        <div
          v-for="(feature, index) in features"
          :key="index"
          class="p-6 rounded-lg shadow-sm bg-[var(--bg-base)]"
        >
          <!-- Icon -->
          <div class="flex items-center justify-center w-12 h-12 rounded-lg text-2xl mb-4">
            {{ feature.icon }}
          </div>

          <!-- Title -->
          <h3>
            {{ feature.title }}
          </h3>

          <!-- Description -->
          <p>
            {{ feature.description }}
          </p>
        </div>
      </LayoutGrid>
    </LayoutContainer>
  </section>
</template>

<script setup lang="ts">
/**
 * FEATURES GRID COMPONENT (PHASE 10)
 *
 * @dev Utilise Container + Grid de Phase 9
 * @dev Tailwind utilities pour styling
 * @dev Cartes avec hover effect
 * @dev Responsive natif via Grid
 */

// Feature interface
export interface Feature {
  icon: string;
  title: string;
  description: string;
}

// Props
interface Props {
  title: string;
  subtitle?: string;
  features: Feature[];
  cols?: 2 | 3 | 4;
}

const props = withDefaults(defineProps<Props>(), {
  cols: 3,
});
</script>

##########
sections/Hero.vue
##########
<template>
  <!--
    Composant Hero - Section d'en-tête

    Description : Section impactante en haut de page avec variants de fond

    Props :
      - variant : 'default' | 'primary' | 'gradient' | 'dark' (défaut: 'default')
      - centered : boolean (centrer le contenu, défaut: true)

    Slots :
      - default : Contenu du Hero (titre, description, CTA)

    @dev Tailwind utilities pour layouts
    @dev Variants via classes dynamiques
  -->
  <section :class="heroClass">
    <div class="container mx-auto px-6 py-20 lg:py-32">
      <div :class="contentClass">
        <slot>
          <h1 class="text-5xl lg:text-6xl font-bold mb-6">
            Design System Moderne
          </h1>
          <p class="text-xl lg:text-2xl mb-8 max-w-2xl">
            Créez des interfaces élégantes avec SwaveConnexion
          </p>
          <div class="flex gap-4 flex-wrap">
            <button class="px-6 py-3 bg-white text-blue-600 font-semibold rounded-lg hover:bg-gray-100 transition-colors">
              Commencer
            </button>
            <button class="px-6 py-3 bg-transparent border-2 border-white text-white font-semibold rounded-lg hover:bg-white/10 transition-colors">
              En savoir plus
            </button>
          </div>
        </slot>
      </div>
    </div>
  </section>
</template>

<script setup lang="ts">
/**
 * HERO COMPONENT
 *
 * @dev Tailwind utilities UNIQUEMENT (NO CSS natif)
 * @dev Variants via computed class
 * @dev Responsive (py-20 lg:py-32)
 */

interface Props {
  variant?: 'default' | 'primary' | 'gradient' | 'dark';
  centered?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'default',
  centered: true,
});

const heroClass = computed(() => {
  const baseClasses = 'relative overflow-hidden';

  const variantClasses: Record<string, string> = {
    default: 'bg-gray-50 text-gray-900',
    primary: 'bg-blue-600 text-white',
    gradient: 'bg-gradient-to-br from-blue-600 via-blue-700 to-blue-900 text-white',
    dark: 'bg-gray-900 text-white',
  };

  return [baseClasses, variantClasses[props.variant]].join(' ');
});

const contentClass = computed(() => {
  return props.centered ? 'text-center mx-auto' : '';
});
</script>

##########
showcase/ShowcaseCodeBlock.vue
##########
<template>
  <!--
    Composant ShowcaseCodeBlock - Code snippet display

    Description : Affiche du code source avec styling

    Input (Props) :
      - code : string (optionnel) - Code à afficher (via prop)
      - language : string (optionnel) - Language du code (typescript, vue, etc.)

    Slots :
      - default : Code à afficher (via slot, priorité sur prop)

    @dev Tailwind utilities uniquement (NO CSS natif scoped)
    @dev Monospace font (JetBrains Mono)
    @dev Dark background avec scroll horizontal
  -->
  <div class="my-4">
    <pre class="showcase-code p-6 rounded-lg overflow-x-auto font-mono text-sm leading-relaxed">{{ displayCode }}</pre>
  </div>
</template>

<script setup lang="ts">
/**
 * CODEBLOCK COMPONENT (PHASE 13)
 *
 * @dev Code snippet display
 * @dev CSS scoped pour couleurs (variables sémantiques)
 * @dev Tailwind utilities pour layout
 * @dev Monospace font avec dark background
 * @dev Support prop ou slot content
 */

// Props
interface Props {
  code?: string;
  language?: string;
}

const props = defineProps<Props>();
const slots = useSlots();

// Computed: Récupérer le code depuis prop ou slot
const displayCode = computed(() => {
  // Priorité au slot
  if (slots.default) {
    const slotContent = slots.default();
    if (slotContent && slotContent[0] && typeof slotContent[0].children === 'string') {
      return slotContent[0].children.trim();
    }
  }

  // Sinon utiliser la prop
  return props.code || '';
});
</script>

<style scoped>
/**
 * SHOWCASECODEBLOCK STYLES
 *
 * @dev Variables CSS sémantiques (adapté dark mode)
 */

.showcase-code {
  background-color: var(--bg-code);
  color: var(--text-code);
}
</style>

##########
showcase/ShowcaseLayout.vue
##########
<template>
  <!--
    Composant ShowcaseLayout - Layout pour pages showcase

    Description : Wrapper réutilisable pour toutes les pages du design system

    Structure:
    ┌─────────────────────────────────────────────┐
    │         Breadcrumb Navigation               │
    ├─────────────────────────────────────────────┤
    │       Gradient Header (title + desc)        │
    ├─────────────────────────────────────────────┤
    │                                             │
    │           Slot Content Area                 │
    │     (ShowcaseSection components)            │
    │                                             │
    └─────────────────────────────────────────────┘

    Input (Props) :
      - title : string (requis) - Titre de la page
      - description : string (requis) - Description de la page

    Slots :
      - default : Contenu de la page (ShowcaseSection)

    @dev CSS scoped pour couleurs (variables sémantiques)
    @dev Tailwind utilities pour layout
    @dev Breadcrumb avec lien vers /design-system
    @dev Gradient header avec title + description
  -->
  <div class="showcase-layout min-h-screen">
    <!-- Breadcrumb -->
    <div class="showcase-breadcrumb border-b">
      <LayoutContainer size="full" :padding="true">
        <nav class="py-4 text-sm">
          <NuxtLink to="/design-system" class="text-primary hover:underline font-medium transition-colors">
            Design System
          </NuxtLink>
          <span class="mx-2 breadcrumb-separator">/</span>
          <span class="breadcrumb-active font-semibold">
            {{ title }}
          </span>
        </nav>
      </LayoutContainer>
    </div>

    <!-- Header avec gradient -->
    <div class="bg-gradient-to-r from-primary to-primary-dark text-white py-16">
      <LayoutContainer size="full" :padding="true">
        <h1 class="text-4xl md:text-5xl font-bold mb-4">{{ title }}</h1>
        <p class="text-xl text-white/90 max-w-3xl">{{ description }}</p>
      </LayoutContainer>
    </div>

    <!-- Content Area -->
    <LayoutContainer size="2xl" :padding="true" class="py-12">
      <slot />
    </LayoutContainer>
  </div>
</template>

<script setup lang="ts">
/**
 * SHOWCASELAYOUT COMPONENT (PHASE 13)
 *
 * @dev Layout wrapper pour pages showcase
 * @dev CSS scoped pour couleurs (variables sémantiques)
 * @dev Tailwind utilities pour layout
 * @dev Breadcrumb + Gradient header + Content area
 * @dev Utilisé par components.vue, feedback.vue, layouts.vue, sections.vue
 */

// Props
interface Props {
  title: string;
  description: string;
}

defineProps<Props>();
</script>

<style scoped>
/**
 * SHOWCASELAYOUT STYLES
 *
 * @dev Variables CSS sémantiques (adapté dark mode)
 */

.showcase-layout {
  background-color: var(--bg-subtle);
}

.showcase-breadcrumb {
  background-color: var(--bg-base);
  border-color: var(--border-base);
}

.breadcrumb-separator {
  color: var(--text-subtle);
}

.breadcrumb-active {
  color: var(--text-strong);
}
</style>

##########
showcase/ShowcaseLayoutDemo.vue
##########
<template>
  <!--
    Composant LayoutDemo - Wrapper pour visualisation de layouts

    Description : Ajoute des bordures néon colorées pour rendre visibles les layouts
                  Utilisé UNIQUEMENT sur /design-system/layouts pour la démo

    Props :
      - color : Couleur du néon (primary, secondary, accent, success, etc.)
      - variant : Style de visualisation (neon, gradient, dashed)

    @dev Phase 13: Visualisation layouts
    @dev NE PAS utiliser en production (uniquement showcase)
  -->
  <div :class="demoClass">
    <slot />
  </div>
</template>

<script setup lang="ts">
/**
 * LAYOUTDEMO COMPONENT (PHASE 13)
 *
 * @dev Wrapper qui ajoute des styles de visualisation aux layouts
 * @dev Bordures néon colorées ou gradients pour voir les limites
 * @dev Utilisé UNIQUEMENT dans /design-system/layouts.vue
 */

// Props
interface Props {
  color?: 'primary' | 'secondary' | 'accent' | 'success' | 'info' | 'warning' | 'error';
  variant?: 'neon' | 'gradient' | 'dashed';
}

const props = withDefaults(defineProps<Props>(), {
  color: 'primary',
  variant: 'neon',
});

// Computed class
const demoClass = computed(() => {
  const baseClasses = 'layout-demo';
  const colorClass = `layout-demo--${props.color}`;
  const variantClass = `layout-demo--${props.variant}`;

  return [baseClasses, colorClass, variantClass].join(' ');
});
</script>

<style scoped>
/**
 * LAYOUT DEMO STYLES
 *
 * Styles de visualisation pour les layouts showcase
 * NE PAS utiliser en production !
 */

/* Base */
.layout-demo {
  position: relative;
}

/* ============================================
   VARIANT: NEON (Défaut)
   ============================================ */

.layout-demo--neon {
  border: 2px solid;
  border-radius: 0.5rem;
  padding: 0.25rem;
  background: rgba(255, 255, 255, 0.02);
}

/* Dark mode: bordure plus visible */
.dark .layout-demo--neon {
  background: rgba(0, 0, 0, 0.1);
}

/* Couleurs néon */
.layout-demo--primary.layout-demo--neon {
  border-color: #2563eb;
  box-shadow: 0 0 10px rgba(37, 99, 235, 0.5), inset 0 0 10px rgba(37, 99, 235, 0.1);
}

.layout-demo--secondary.layout-demo--neon {
  border-color: #525252;
  box-shadow: 0 0 10px rgba(82, 82, 82, 0.5), inset 0 0 10px rgba(82, 82, 82, 0.1);
}

.layout-demo--accent.layout-demo--neon {
  border-color: #f59e0b;
  box-shadow: 0 0 10px rgba(245, 158, 11, 0.6), inset 0 0 10px rgba(245, 158, 11, 0.1);
}

.layout-demo--success.layout-demo--neon {
  border-color: #10b981;
  box-shadow: 0 0 10px rgba(16, 185, 129, 0.6), inset 0 0 10px rgba(16, 185, 129, 0.1);
}

.layout-demo--info.layout-demo--neon {
  border-color: #3b82f6;
  box-shadow: 0 0 10px rgba(59, 130, 246, 0.6), inset 0 0 10px rgba(59, 130, 246, 0.1);
}

.layout-demo--warning.layout-demo--neon {
  border-color: #f59e0b;
  box-shadow: 0 0 10px rgba(245, 158, 11, 0.6), inset 0 0 10px rgba(245, 158, 11, 0.1);
}

.layout-demo--error.layout-demo--neon {
  border-color: #ef4444;
  box-shadow: 0 0 10px rgba(239, 68, 68, 0.6), inset 0 0 10px rgba(239, 68, 68, 0.1);
}

/* ============================================
   VARIANT: GRADIENT
   ============================================ */

.layout-demo--gradient {
  border: 3px solid transparent;
  border-radius: 0.5rem;
  padding: 0.25rem;
  background-origin: border-box;
  background-clip: padding-box, border-box;
}

.layout-demo--primary.layout-demo--gradient {
  background-image:
    linear-gradient(white, white),
    linear-gradient(90deg, #2563eb, #60a5fa, #2563eb);
}

.dark .layout-demo--primary.layout-demo--gradient {
  background-image:
    linear-gradient(#262626, #262626),
    linear-gradient(90deg, #2563eb, #60a5fa, #2563eb);
}

.layout-demo--accent.layout-demo--gradient {
  background-image:
    linear-gradient(white, white),
    linear-gradient(90deg, #f59e0b, #fbbf24, #f59e0b);
}

.dark .layout-demo--accent.layout-demo--gradient {
  background-image:
    linear-gradient(#262626, #262626),
    linear-gradient(90deg, #f59e0b, #fbbf24, #f59e0b);
}

.layout-demo--success.layout-demo--gradient {
  background-image:
    linear-gradient(white, white),
    linear-gradient(90deg, #10b981, #34d399, #10b981);
}

.dark .layout-demo--success.layout-demo--gradient {
  background-image:
    linear-gradient(#262626, #262626),
    linear-gradient(90deg, #10b981, #34d399, #10b981);
}

/* ============================================
   VARIANT: DASHED
   ============================================ */

.layout-demo--dashed {
  border: 2px dashed;
  border-radius: 0.5rem;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.02);
}

.dark .layout-demo--dashed {
  background: rgba(0, 0, 0, 0.1);
}

.layout-demo--primary.layout-demo--dashed {
  border-color: #2563eb;
}

.layout-demo--accent.layout-demo--dashed {
  border-color: #f59e0b;
}

.layout-demo--success.layout-demo--dashed {
  border-color: #10b981;
}

.layout-demo--error.layout-demo--dashed {
  border-color: #ef4444;
}
</style>

##########
showcase/ShowcaseSection.vue
##########
<template>
  <!--
    Composant ShowcaseSection - Section wrapper

    Description : Card wrapper pour chaque section de showcase

    Structure:
    ┌─────────────────────────────────────────────┐
    │           Title (h2)                        │
    ├─────────────────────────────────────────────┤
    │                                             │
    │       White Card Container                  │
    │         (Slot Content)                      │
    │                                             │
    └─────────────────────────────────────────────┘

    Input (Props) :
      - title : string (requis) - Titre de la section

    Slots :
      - default : Contenu de la section (démos, code, etc.)

    @dev CSS scoped pour couleurs (variables sémantiques)
    @dev Tailwind utilities pour layout
    @dev White card avec border et padding
    @dev Dark mode support
  -->
  <section class="mb-12">
    <h2 class="showcase-title text-2xl md:text-3xl font-bold mb-6">
      {{ title }}
    </h2>
    <div class="showcase-card rounded-lg p-8 shadow-sm">
      <slot />
    </div>
  </section>
</template>

<script setup lang="ts">
/**
 * SHOWCASESECTION COMPONENT (PHASE 13)
 *
 * @dev Section wrapper pour showcase pages
 * @dev CSS scoped pour couleurs (variables sémantiques)
 * @dev Tailwind utilities pour layout
 * @dev Title + white card container
 * @dev Utilisé dans ShowcaseLayout pour organiser le contenu
 */

// Props
interface Props {
  title: string;
}

defineProps<Props>();
</script>

<style scoped>
/**
 * SHOWCASESECTION STYLES
 *
 * @dev Variables CSS sémantiques (adapté dark mode)
 */

.showcase-title {
  color: var(--text-strong);
}

.showcase-card {
  background-color: var(--bg-base);
  border: 1px solid var(--border-base);
}
</style>

##########
ui/Badge.vue
##########
<template>
  <!--
    Composant Badge - Tag/Badge

    Description : Badge coloré pour statuts, tags

    Input (Props) :
      - variant : 'primary' | 'secondary' | 'accent' | 'success' | 'warning' | 'error'
      - size : 'sm' | 'md'

    Slots :
      - default : Contenu du badge
  -->
  <span :class="badgeClass">
    <slot />
  </span>
</template>

<script setup lang="ts">
/**
 * BADGE COMPONENT
 *
 * @dev Simple span inline avec couleurs sémantiques
 * @dev BEM : .badge, .badge--primary, .badge--sm
 */

// Props
interface Props {
  variant?: 'primary' | 'secondary' | 'accent' | 'success' | 'warning' | 'error';
  size?: 'sm' | 'md';
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'primary',
  size: 'md',
});

// Computed class BEM
const badgeClass = computed(() => {
  return [
    'badge',
    `badge--${props.variant}`,
    `badge--${props.size}`,
  ].join(' ');
});
</script>

<style scoped>
/**
 * BADGE STYLES - BEM strict
 */

/* Block : .badge */
.badge {
  display: inline-flex;
  align-items: center;
  font-family: var(--font-sans);
  font-weight: var(--font-medium);
  border-radius: var(--radius-full);
  white-space: nowrap;
}

/* Modifier : Variantes */
.badge--primary {
  background-color: var(--primary-light);
  color: var(--primary-dark);
}

.badge--secondary {
  background-color: var(--secondary-light);
  color: var(--secondary-dark);
}

.badge--accent {
  background-color: var(--accent-light);
  color: var(--accent-dark);
}

.badge--success {
  background-color: var(--success-light);
  color: var(--success-dark);
}

.badge--warning {
  background-color: var(--warning-light);
  color: var(--warning-dark);
}

.badge--error {
  background-color: var(--error-light);
  color: var(--error-dark);
}

/* Modifier : Tailles */
.badge--sm {
  padding: 0.25rem 0.5rem;
  font-size: var(--text-xs);
}

.badge--md {
  padding: 0.375rem 0.75rem;
  font-size: var(--text-sm);
}
</style>

##########
ui/Button.vue
##########
<template>
  <!--
    Composant Button - Bouton réutilisable

    Description : Bouton avec variantes de couleur et tailles

    Input (Props) :
      - variant : 'primary' | 'secondary' | 'accent' | 'outline' | 'outline-light' (défaut: 'primary')
      - size : 'sm' | 'md' | 'lg' (défaut: 'md')
      - disabled : boolean (défaut: false)

    Output (Events) :
      - click : Émis lors du clic

    Slots :
      - default : Contenu du bouton
  -->
  <button
    :class="btnClass"
    :disabled="disabled"
    @click="emit('click', $event)"
  >
    <slot />
  </button>
</template>

<script setup lang="ts">
/**
 * BUTTON COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .btn, .btn--primary, .btn--sm
 */

// Props
interface Props {
  variant?: 'primary' | 'secondary' | 'accent' | 'outline' | 'outline-light';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'primary',
  size: 'md',
  disabled: false,
});

// Events
interface Emits {
  click: [event: MouseEvent];
}

const emit = defineEmits<Emits>();

// Computed class BEM
const btnClass = computed(() => {
  return [
    'btn',
    `btn--${props.variant}`,
    `btn--${props.size}`,
    props.disabled && 'btn--disabled',
  ].filter(Boolean).join(' ');
});
</script>

<style scoped>
/**
 * BUTTON STYLES - BEM strict
 *
 * @dev Variables de _variables.css et _typography.css
 */

/* Block : .btn */
.btn {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: var(--space-xs);
  font-family: var(--font-sans);
  font-weight: var(--font-medium);
  border: var(--border-width) solid transparent;
  border-radius: var(--radius-md);
  cursor: pointer;
  transition: all 0.2s ease;
}

.btn:focus-visible {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* Modifier : Variantes */
.btn--primary {
  background-color: var(--primary);
  color: var(--text-inverse);
}

.btn--primary:hover:not(.btn--disabled) {
  background-color: var(--primary-dark);
}

.btn--secondary {
  background-color: var(--secondary);
  color: var(--text-inverse);
}

.btn--secondary:hover:not(.btn--disabled) {
  background-color: var(--secondary-dark);
}

.btn--accent {
  background-color: var(--accent);
  color: var(--text-inverse);
}

.btn--accent:hover:not(.btn--disabled) {
  background-color: var(--accent-dark);
}

.btn--outline {
  background-color: transparent;
  color: var(--primary);
  border-color: var(--primary);
}

.btn--outline:hover:not(.btn--disabled) {
  background-color: var(--primary-light);
  color: var(--text-inverse);
}

.btn--outline-light {
  background-color: transparent;
  color: var(--text-inverse);
  border-color: var(--text-inverse);
}

.btn--outline-light:hover:not(.btn--disabled) {
  background-color: var(--text-inverse);
  color: var(--primary);
}

/* Modifier : Tailles */
.btn--sm {
  padding: var(--space-xs) var(--space-sm);
  font-size: var(--text-sm);
}

.btn--md {
  padding: var(--space-sm) var(--space-md);
  font-size: var(--text-base);
}

.btn--lg {
  padding: var(--space-md) var(--space-lg);
  font-size: var(--text-lg);
}

/* Modifier : Désactivé */
.btn--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
</style>

##########
ui/Card.vue
##########
<template>
  <!--
    Composant Card - Carte conteneur

    Description : Carte avec header et footer optionnels

    Input (Props) :
      - variant : 'default' | 'bordered' | 'elevated' (défaut: 'default')

    Slots :
      - header : En-tête optionnel
      - default : Contenu principal
      - footer : Pied de page optionnel
  -->
  <div :class="cardClass">
    <div v-if="$slots.header" class="card__header">
      <slot name="header" />
    </div>

    <div class="card__body">
      <slot />
    </div>

    <div v-if="$slots.footer" class="card__footer">
      <slot name="footer" />
    </div>
  </div>
</template>

<script setup lang="ts">
/**
 * CARD COMPONENT
 *
 * @dev Structure simple : header, body, footer (optionnels)
 * @dev BEM : .card, .card__header, .card__body, .card__footer
 */

// Props
interface Props {
  variant?: 'default' | 'bordered' | 'elevated';
}

const props = withDefaults(defineProps<Props>(), {
  variant: 'default',
});

// Computed class BEM
const cardClass = computed(() => {
  return ['card', `card--${props.variant}`].join(' ');
});
</script>

<style scoped>
/**
 * CARD STYLES - BEM strict
 * PRD v2.0 - Phase 3: Migré vers variables sémantiques
 */

/* Block : .card */
.card {
  background-color: var(--bg-base);
  border-radius: var(--radius-lg);
  overflow: hidden;
}

/* Element : .card__header */
.card__header {
  padding: var(--space-md);
  border-bottom: var(--border-width) solid var(--border-base);
}

/* Element : .card__body */
.card__body {
  padding: var(--space-md);
}

/* Element : .card__footer */
.card__footer {
  padding: var(--space-md);
  border-top: var(--border-width) solid var(--border-base);
  background-color: var(--bg-subtle);
}

/* Modifier : Variantes */
.card--default {
  border: var(--border-width) solid var(--border-base);
}

.card--bordered {
  border: var(--border-width-thick) solid var(--border-strong);
}

.card--elevated {
  border: none;
  box-shadow: var(--shadow-lg);
}
</style>

##########
ui/Checkbox.vue
##########
<template>
  <!--
    Composant Checkbox - Case à cocher réutilisable

    Description : Case à cocher avec label et support v-model

    Input (Props) :
      - modelValue : boolean (défaut: false) - État coché
      - label : string (optionnel) - Texte du label
      - disabled : boolean (défaut: false)
      - indeterminate : boolean (défaut: false) - État indéterminé

    Output (Events) :
      - update:modelValue : Émis lors du changement

    Slots :
      - default : Remplace le label si fourni
  -->
  <label :class="checkboxClass">
    <input
      type="checkbox"
      class="checkbox__input"
      :checked="modelValue"
      :disabled="disabled"
      :indeterminate="indeterminate"
      @change="handleChange"
    />
    <span class="checkbox__checkmark"></span>
    <span v-if="label || $slots.default" class="checkbox__label">
      <slot>{{ label }}</slot>
    </span>
  </label>
</template>

<script setup lang="ts">
/**
 * CHECKBOX COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .checkbox, .checkbox__input, .checkbox__label, .checkbox--disabled
 * @dev Support v-model avec modelValue
 */

// Props
interface Props {
  modelValue?: boolean;
  label?: string;
  disabled?: boolean;
  indeterminate?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  modelValue: false,
  label: '',
  disabled: false,
  indeterminate: false,
});

// Events
interface Emits {
  'update:modelValue': [value: boolean];
}

const emit = defineEmits<Emits>();

// Computed class BEM
const checkboxClass = computed(() => {
  return [
    'checkbox',
    props.disabled && 'checkbox--disabled',
    props.indeterminate && 'checkbox--indeterminate',
  ].filter(Boolean).join(' ');
});

// Handle change
const handleChange = (event: Event) => {
  const target = event.target as HTMLInputElement;
  emit('update:modelValue', target.checked);
};
</script>

<style scoped>
/**
 * CHECKBOX STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .checkbox */
.checkbox {
  display: inline-flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  position: relative;
}

.checkbox--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Element : .checkbox__input (hidden) */
.checkbox__input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

/* Element : .checkbox__checkmark (custom checkbox) */
.checkbox__checkmark {
  display: inline-block;
  width: 20px;
  height: 20px;
  border: var(--border-width-thick) solid var(--border-base);
  border-radius: var(--radius-sm);
  background-color: var(--bg-base);
  position: relative;
  transition: all 0.2s ease;
  flex-shrink: 0;
}

/* Checkmark icon (hidden by default) */
.checkbox__checkmark::after {
  content: '';
  position: absolute;
  display: none;
  left: 5px;
  top: 1px;
  width: 6px;
  height: 11px;
  border: solid var(--text-inverse);
  border-width: 0 2px 2px 0;
  transform: rotate(45deg);
}

/* Checked state */
.checkbox__input:checked ~ .checkbox__checkmark {
  background-color: var(--primary);
  border-color: var(--primary);
}

.checkbox__input:checked ~ .checkbox__checkmark::after {
  display: block;
}

/* Indeterminate state (ligne horizontale) */
.checkbox--indeterminate .checkbox__checkmark {
  background-color: var(--primary);
  border-color: var(--primary);
}

.checkbox--indeterminate .checkbox__checkmark::after {
  display: block;
  left: 4px;
  top: 7px;
  width: 10px;
  height: 0;
  border: none;
  border-bottom: 2px solid var(--text-inverse);
  transform: none;
}

/* Focus visible */
.checkbox__input:focus-visible ~ .checkbox__checkmark {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* Hover (non-disabled) */
.checkbox:hover:not(.checkbox--disabled) .checkbox__checkmark {
  border-color: var(--primary);
}

/* Element : .checkbox__label */
.checkbox__label {
  font-family: var(--font-sans);
  font-size: var(--text-base);
  color: var(--text-strong);
  user-select: none;
}

.checkbox--disabled .checkbox__label {
  color: var(--text-subtle);
}
</style>

##########
ui/Dropdown.vue
##########
<template>
  <!--
    Composant Dropdown - Menu déroulant

    Description : Menu contextuel avec items cliquables

    Input (Props) :
      - items : Array<{label: string, value: string}>
      - placeholder : Texte par défaut

    Output (Events) :
      - select : Émis lors de la sélection (value)
  -->
  <div class="dropdown" ref="dropdownRef">
    <button class="dropdown__trigger" @click="isOpen = !isOpen">
      {{ selectedLabel || placeholder }}
      <span class="dropdown__arrow">▼</span>
    </button>

    <Transition name="dropdown">
      <ul v-if="isOpen" class="dropdown__menu">
        <li
          v-for="item in items"
          :key="item.value"
          class="dropdown__item"
          @click="selectItem(item)"
        >
          {{ item.label }}
        </li>
      </ul>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { onClickOutside } from '@vueuse/core';

/**
 * DROPDOWN COMPONENT
 *
 * @dev Fermeture au clic extérieur via onClickOutside
 * @dev BEM : .dropdown, .dropdown__trigger, .dropdown__menu, .dropdown__item
 */

// Types
interface DropdownItem {
  label: string;
  value: string;
}

// Props
interface Props {
  items: DropdownItem[];
  placeholder?: string;
}

const props = withDefaults(defineProps<Props>(), {
  placeholder: 'Sélectionner',
});

// Events
interface Emits {
  select: [value: string];
}

const emit = defineEmits<Emits>();

// State
const isOpen = ref(false);
const selectedLabel = ref('');
const dropdownRef = ref<HTMLElement | null>(null);

// Sélection d'un item
const selectItem = (item: DropdownItem) => {
  selectedLabel.value = item.label;
  emit('select', item.value);
  isOpen.value = false;
};

// Fermeture au clic extérieur
onClickOutside(dropdownRef, () => {
  isOpen.value = false;
});
</script>

<style scoped>
/**
 * DROPDOWN STYLES - BEM strict
 */

/* Block : .dropdown */
.dropdown {
  position: relative;
  display: inline-block;
}

/* Element : .dropdown__trigger */
.dropdown__trigger {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: var(--space-sm);
  padding: var(--space-sm) var(--space-md);
  font-size: var(--text-base);
  color: var(--text-base);
  background-color: var(--bg-base);
  border: var(--border-width) solid var(--border-base);
  border-radius: var(--radius-md);
  cursor: pointer;
  min-width: 200px;
}

.dropdown__trigger:hover {
  border-color: var(--primary);
}

/* Element : .dropdown__arrow */
.dropdown__arrow {
  font-size: var(--text-xs);
  color: var(--text-base);
}

/* Element : .dropdown__menu */
.dropdown__menu {
  position: absolute;
  top: calc(100% + 0.25rem);
  left: 0;
  right: 0;
  background-color: var(--bg-elevated);
  border: var(--border-width) solid var(--border-base);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-md);
  list-style: none;
  padding: 0;
  margin: 0;
  max-height: 300px;
  overflow-y: auto;
  z-index: 100;
}

/* Element : .dropdown__item */
.dropdown__item {
  padding: var(--space-sm) var(--space-md);
  font-size: var(--text-base);
  color: var(--text-base);
  cursor: pointer;
}

.dropdown__item:hover {
  background-color: var(--bg-hover);
  color: var(--primary);
}

/* Transitions */
.dropdown-enter-active,
.dropdown-leave-active {
  transition: opacity 0.15s ease, transform 0.15s ease;
}

.dropdown-enter-from,
.dropdown-leave-to {
  opacity: 0;
  transform: translateY(-8px);
}
</style>

##########
ui/Input.vue
##########
<template>
  <!--
    Composant Input - Champ de formulaire

    Description : Input text avec label et error

    Input (Props) :
      - label : Libellé du champ
      - type : Type HTML (text, email, password, etc.)
      - modelValue : Valeur v-model
      - error : Message d'erreur
      - placeholder : Texte placeholder

    Output (Events) :
      - update:modelValue : Émis lors de la saisie
  -->
  <div class="input-group">
    <label v-if="label" :for="inputId" class="input-group__label">
      {{ label }}
    </label>

    <input
      :id="inputId"
      :class="inputClass"
      :type="type"
      :value="modelValue"
      :placeholder="placeholder"
      @input="emit('update:modelValue', ($event.target as HTMLInputElement).value)"
    />

    <span v-if="error" class="input-group__error">
      {{ error }}
    </span>
  </div>
</template>

<script setup lang="ts">
/**
 * INPUT COMPONENT
 *
 * @dev Utilise v-model pour binding bidirectionnel
 * @dev BEM : .input-group, .input-group__label, .input-group__input, .input-group__error
 */

// Props
interface Props {
  label?: string;
  type?: string;
  modelValue?: string;
  error?: string;
  placeholder?: string;
}

const props = withDefaults(defineProps<Props>(), {
  type: 'text',
  modelValue: '',
});

// Events
interface Emits {
  'update:modelValue': [value: string];
}

const emit = defineEmits<Emits>();

// ID unique pour label/input (SSR-safe)
const inputId = useId();

// Computed class BEM
const inputClass = computed(() => {
  return [
    'input-group__input',
    props.error && 'input-group__input--error',
  ].filter(Boolean).join(' ');
});
</script>

<style scoped>
/**
 * INPUT STYLES - BEM strict
 */

/* Block : .input-group */
.input-group {
  display: flex;
  flex-direction: column;
  gap: var(--space-xs);
}

/* Element : .input-group__label */
.input-group__label {
  font-size: var(--text-sm);
  font-weight: var(--font-medium);
  color: var(--text-base);
}

/* Element : .input-group__input */
.input-group__input {
  padding: var(--space-sm);
  font-size: var(--text-base);
  color: var(--text-strong);
  background-color: var(--bg-input);
  border: var(--border-width) solid var(--border-base);
  border-radius: var(--radius-md);
  transition: border-color 0.2s ease;
}

.input-group__input:focus {
  outline: none;
  border-color: var(--primary);
}

.input-group__input::placeholder {
  color: var(--text-subtle);
}

/* Modifier : Erreur */
.input-group__input--error {
  border-color: var(--error);
}

/* Element : .input-group__error */
.input-group__error {
  font-size: var(--text-xs);
  color: var(--error);
}
</style>

##########
ui/Modal.vue
##########
<template>
  <!--
    Composant Modal - Modale accessible

    Description : Overlay modale avec fermeture ESC/backdrop

    Input (Props) :
      - isOpen : boolean - Contrôle l'affichage
      - title : Titre de la modale

    Output (Events) :
      - close : Émis lors de la fermeture

    Slots :
      - default : Contenu de la modale
      - footer : Actions (boutons)
  -->
  <Teleport to="body">
    <Transition name="modal">
      <div v-if="isOpen" class="modal" @click="emit('close')">
        <div class="modal__backdrop"></div>

        <div class="modal__container" @click.stop>
          <div class="modal__header">
            <h3 class="modal__title">{{ title }}</h3>
            <button class="modal__close" @click="emit('close')" aria-label="Fermer">
              ✕
            </button>
          </div>

          <div class="modal__body">
            <slot />
          </div>

          <div v-if="$slots.footer" class="modal__footer">
            <slot name="footer" />
          </div>
        </div>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup lang="ts">
import { onKeyStroke } from '@vueuse/core';

/**
 * MODAL COMPONENT
 *
 * @dev Teleport vers body pour overlay
 * @dev Fermeture ESC via onKeyStroke (composable Vue)
 * @dev BEM : .modal, .modal__backdrop, .modal__container
 */

// Props
interface Props {
  isOpen: boolean;
  title?: string;
}

const props = withDefaults(defineProps<Props>(), {
  title: 'Modal',
});

// Events
interface Emits {
  close: [];
}

const emit = defineEmits<Emits>();

// Fermeture avec ESC
onKeyStroke('Escape', () => {
  if (props.isOpen) emit('close');
});

// Bloquer le scroll du body quand modal ouverte
watch(() => props.isOpen, (open) => {
  if (open) {
    document.body.style.overflow = 'hidden';
  } else {
    document.body.style.overflow = '';
  }
});
</script>

<style scoped>
/**
 * MODAL STYLES - BEM strict
 */

/* Block : .modal */
.modal {
  position: fixed;
  inset: 0;
  z-index: 1000;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-md);
}

/* Element : .modal__backdrop */
.modal__backdrop {
  position: absolute;
  inset: 0;
  background-color: rgba(0, 0, 0, 0.5);
}

/* Element : .modal__container */
.modal__container {
  position: relative;
  background-color: var(--bg-base);
  border-radius: var(--radius-lg);
  box-shadow: var(--shadow-xl);
  max-width: 500px;
  width: 100%;
  max-height: 80vh;
  overflow-y: auto;
}

/* Element : .modal__header */
.modal__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: var(--space-md);
  border-bottom: var(--border-width) solid var(--border-base);
}

/* Element : .modal__title */
.modal__title {
  margin: 0;
  font-size: var(--text-2xl);
  font-weight: var(--font-semibold);
}

/* Element : .modal__close */
.modal__close {
  padding: var(--space-xs);
  font-size: var(--text-xl);
  color: var(--text-base);
  background: none;
  border: none;
  cursor: pointer;
  border-radius: var(--radius-sm);
}

.modal__close:hover {
  background-color: var(--bg-hover);
}

/* Element : .modal__body */
.modal__body {
  padding: var(--space-md);
}

/* Element : .modal__footer */
.modal__footer {
  display: flex;
  gap: var(--space-sm);
  justify-content: flex-end;
  padding: var(--space-md);
  border-top: var(--border-width) solid var(--border-base);
}

/* Transitions */
.modal-enter-active,
.modal-leave-active {
  transition: opacity 0.2s ease;
}

.modal-enter-from,
.modal-leave-to {
  opacity: 0;
}
</style>

##########
ui/ProgressBar.vue
##########
<template>
  <!--
    Composant ProgressBar - Barre de progression

    Description : Barre de progression linéaire avec variantes

    Input (Props) :
      - value : number (0-100, défaut: 0) - Progression
      - variant : 'primary' | 'success' | 'warning' | 'error' (défaut: 'primary')
      - showLabel : boolean (défaut: false) - Affiche le pourcentage
      - animated : boolean (défaut: false) - Animation de la barre

    Output (Events) :
      Aucun

    Slots :
      Aucun
  -->
  <div :class="progressClass">
    <div class="progress__track">
      <div
        class="progress__bar"
        :style="progressStyle"
        role="progressbar"
        :aria-valuenow="value"
        aria-valuemin="0"
        aria-valuemax="100"
      ></div>
    </div>
    <span v-if="showLabel" class="progress__label">{{ value }}%</span>
  </div>
</template>

<script setup lang="ts">
/**
 * PROGRESS BAR COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .progress, .progress__track, .progress__bar, .progress--animated
 * @dev Transition CSS smooth sur width
 */

// Props
interface Props {
  value?: number;
  variant?: 'primary' | 'success' | 'warning' | 'error';
  showLabel?: boolean;
  animated?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  value: 0,
  variant: 'primary',
  showLabel: false,
  animated: false,
});

// Computed class BEM
const progressClass = computed(() => {
  return [
    'progress',
    `progress--${props.variant}`,
    props.animated && 'progress--animated',
  ].filter(Boolean).join(' ');
});

// Computed style for progress bar width
const progressStyle = computed(() => {
  const clampedValue = Math.min(Math.max(props.value, 0), 100);
  return {
    width: `${clampedValue}%`,
  };
});
</script>

<style scoped>
/**
 * PROGRESS BAR STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .progress */
.progress {
  display: flex;
  align-items: center;
  gap: var(--space-sm);
  width: 100%;
}

/* Element : .progress__track */
.progress__track {
  flex: 1;
  height: 8px;
  background-color: var(--bg-subtle);
  border-radius: var(--radius-full);
  overflow: hidden;
  position: relative;
}

/* Element : .progress__bar */
.progress__bar {
  height: 100%;
  border-radius: var(--radius-full);
  transition: width 0.3s ease;
}

/* Variant : primary */
.progress--primary .progress__bar {
  background-color: var(--primary);
}

/* Variant : success */
.progress--success .progress__bar {
  background-color: var(--success);
}

/* Variant : warning */
.progress--warning .progress__bar {
  background-color: var(--warning);
}

/* Variant : error */
.progress--error .progress__bar {
  background-color: var(--error);
}

/* Modifier : animated (stripe animation) */
.progress--animated .progress__bar {
  background-image: linear-gradient(
    45deg,
    rgba(255, 255, 255, 0.15) 25%,
    transparent 25%,
    transparent 50%,
    rgba(255, 255, 255, 0.15) 50%,
    rgba(255, 255, 255, 0.15) 75%,
    transparent 75%,
    transparent
  );
  background-size: 20px 20px;
  animation: progress-stripes 1s linear infinite;
}

@keyframes progress-stripes {
  from {
    background-position: 0 0;
  }
  to {
    background-position: 20px 0;
  }
}

/* Element : .progress__label */
.progress__label {
  font-family: var(--font-mono);
  font-size: var(--text-sm);
  color: var(--text-base);
  min-width: 40px;
  text-align: right;
  font-weight: var(--font-medium);
}
</style>

##########
ui/Switch.vue
##########
<template>
  <!--
    Composant Switch - Toggle on/off

    Description : Interrupteur minimaliste avec animation

    Input (Props) :
      - modelValue : boolean (défaut: false) - État on/off
      - label : string (optionnel) - Texte du label
      - disabled : boolean (défaut: false)
      - size : 'sm' | 'md' (défaut: 'md')

    Output (Events) :
      - update:modelValue : Émis lors du changement

    Slots :
      - default : Remplace le label si fourni
  -->
  <label :class="switchClass">
    <input
      type="checkbox"
      class="switch__input"
      :checked="modelValue"
      :disabled="disabled"
      @change="handleChange"
    />
    <span class="switch__track">
      <span class="switch__thumb"></span>
    </span>
    <span v-if="label || $slots.default" class="switch__label">
      <slot>{{ label }}</slot>
    </span>
  </label>
</template>

<script setup lang="ts">
/**
 * SWITCH COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .switch, .switch__track, .switch__thumb, .switch--checked
 * @dev Animation smooth du thumb avec transition CSS
 */

// Props
interface Props {
  modelValue?: boolean;
  label?: string;
  disabled?: boolean;
  size?: 'sm' | 'md';
}

const props = withDefaults(defineProps<Props>(), {
  modelValue: false,
  label: '',
  disabled: false,
  size: 'md',
});

// Events
interface Emits {
  'update:modelValue': [value: boolean];
}

const emit = defineEmits<Emits>();

// Computed class BEM
const switchClass = computed(() => {
  return [
    'switch',
    `switch--${props.size}`,
    props.modelValue && 'switch--checked',
    props.disabled && 'switch--disabled',
  ].filter(Boolean).join(' ');
});

// Handle change
const handleChange = (event: Event) => {
  const target = event.target as HTMLInputElement;
  emit('update:modelValue', target.checked);
};
</script>

<style scoped>
/**
 * SWITCH STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .switch */
.switch {
  display: inline-flex;
  align-items: center;
  gap: var(--space-sm);
  cursor: pointer;
  position: relative;
}

.switch--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Element : .switch__input (hidden) */
.switch__input {
  position: absolute;
  opacity: 0;
  width: 0;
  height: 0;
}

/* Element : .switch__track */
.switch__track {
  display: inline-block;
  position: relative;
  background-color: var(--bg-active);
  border-radius: var(--radius-full);
  transition: background-color 0.3s ease;
  flex-shrink: 0;
}

/* Taille MD (défaut) */
.switch--md .switch__track {
  width: 44px;
  height: 24px;
}

/* Taille SM */
.switch--sm .switch__track {
  width: 36px;
  height: 20px;
}

/* Element : .switch__thumb */
.switch__thumb {
  position: absolute;
  top: 2px;
  left: 2px;
  background-color: var(--bg-base);
  border-radius: var(--radius-full);
  transition: transform 0.3s ease;
  box-shadow: var(--shadow-sm);
}

/* Taille MD thumb */
.switch--md .switch__thumb {
  width: 20px;
  height: 20px;
}

/* Taille SM thumb */
.switch--sm .switch__thumb {
  width: 16px;
  height: 16px;
}

/* Checked state */
.switch--checked .switch__track {
  background-color: var(--primary);
}

/* MD thumb translation when checked */
.switch--md.switch--checked .switch__thumb {
  transform: translateX(20px);
}

/* SM thumb translation when checked */
.switch--sm.switch--checked .switch__thumb {
  transform: translateX(16px);
}

/* Focus visible */
.switch__input:focus-visible ~ .switch__track {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* Hover (non-disabled) */
.switch:hover:not(.switch--disabled) .switch__track {
  opacity: 0.9;
}

/* Element : .switch__label */
.switch__label {
  font-family: var(--font-sans);
  font-size: var(--text-base);
  color: var(--text-strong);
  user-select: none;
}

.switch--disabled .switch__label {
  color: var(--text-subtle);
}
</style>

##########
ui/Tabs.vue
##########
<template>
  <!--
    Composant Tabs - Navigation par onglets

    Description : Système d'onglets avec keyboard navigation

    Input (Props) :
      - modelValue : string (requis) - Value de l'onglet actif
      - items : TabItem[] (requis) - Liste des onglets

    TabItem interface:
      - label : string - Texte de l'onglet
      - value : string - Valeur unique
      - disabled : boolean (optionnel) - Onglet désactivé

    Output (Events) :
      - update:modelValue : Émis lors du changement d'onglet

    Slots :
      - default : Contenu de l'onglet actif (utiliser v-if avec modelValue)
  -->
  <div class="tabs">
    <!-- Tab list -->
    <div
      class="tabs__list"
      role="tablist"
      @keydown="handleKeyDown"
    >
      <button
        v-for="(item, index) in items"
        :key="item.value"
        :class="getTabClass(item)"
        role="tab"
        :aria-selected="modelValue === item.value"
        :aria-disabled="item.disabled"
        :tabindex="getTabIndex(item, index)"
        @click="selectTab(item)"
        @focus="currentFocusIndex = index"
      >
        {{ item.label }}
      </button>
    </div>

    <!-- Tab panels (content) -->
    <div class="tabs__panels">
      <slot />
    </div>
  </div>
</template>

<script setup lang="ts">
/**
 * TABS COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .tabs, .tabs__list, .tabs__item, .tabs__item--active
 * @dev Keyboard navigation : Arrow keys, Home, End
 * @dev ARIA complet : role=tablist, role=tab, aria-selected
 */

// Types
interface TabItem {
  label: string;
  value: string;
  disabled?: boolean;
}

// Props
interface Props {
  modelValue: string;
  items: TabItem[];
}

const props = defineProps<Props>();

// Events
interface Emits {
  'update:modelValue': [value: string];
}

const emit = defineEmits<Emits>();

// State for keyboard navigation
const currentFocusIndex = ref(0);

// Select tab
const selectTab = (item: TabItem) => {
  if (!item.disabled) {
    emit('update:modelValue', item.value);
  }
};

// Get tab class BEM
const getTabClass = (item: TabItem) => {
  return [
    'tabs__item',
    props.modelValue === item.value && 'tabs__item--active',
    item.disabled && 'tabs__item--disabled',
  ].filter(Boolean).join(' ');
};

// Get tab index for keyboard navigation
const getTabIndex = (item: TabItem, index: number) => {
  // Active tab is always focusable
  if (props.modelValue === item.value) return 0;
  // Disabled tabs are not focusable
  if (item.disabled) return -1;
  // Other tabs are not in tab order (keyboard nav with arrows)
  return -1;
};

// Keyboard navigation
const handleKeyDown = (event: KeyboardEvent) => {
  const { key } = event;
  const enabledItems = props.items.filter(item => !item.disabled);

  if (!enabledItems.length) return;

  let newIndex = currentFocusIndex.value;

  switch (key) {
    case 'ArrowRight':
    case 'ArrowDown':
      event.preventDefault();
      // Move to next enabled tab
      do {
        newIndex = (newIndex + 1) % props.items.length;
      } while (props.items[newIndex].disabled);
      break;

    case 'ArrowLeft':
    case 'ArrowUp':
      event.preventDefault();
      // Move to previous enabled tab
      do {
        newIndex = (newIndex - 1 + props.items.length) % props.items.length;
      } while (props.items[newIndex].disabled);
      break;

    case 'Home':
      event.preventDefault();
      // Move to first enabled tab
      newIndex = props.items.findIndex(item => !item.disabled);
      break;

    case 'End':
      event.preventDefault();
      // Move to last enabled tab
      newIndex = props.items.length - 1 - [...props.items].reverse().findIndex(item => !item.disabled);
      break;

    default:
      return;
  }

  currentFocusIndex.value = newIndex;
  selectTab(props.items[newIndex]);
};
</script>

<style scoped>
/**
 * TABS STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .tabs */
.tabs {
  display: flex;
  flex-direction: column;
  gap: var(--space-md);
}

/* Element : .tabs__list */
.tabs__list {
  display: flex;
  gap: var(--space-xs);
  border-bottom: var(--border-width-thick) solid var(--border-base);
}

/* Element : .tabs__item */
.tabs__item {
  padding: var(--space-sm) var(--space-md);
  font-family: var(--font-sans);
  font-size: var(--text-base);
  font-weight: var(--font-medium);
  color: var(--text-base);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  cursor: pointer;
  transition: all 0.2s ease;
  position: relative;
  bottom: -2px;
}

.tabs__item:hover:not(.tabs__item--disabled) {
  color: var(--primary);
}

.tabs__item:focus-visible {
  outline: 2px solid var(--primary);
  outline-offset: 2px;
}

/* Modifier : active */
.tabs__item--active {
  color: var(--primary);
  border-bottom-color: var(--primary);
}

/* Modifier : disabled */
.tabs__item--disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

/* Element : .tabs__panels */
.tabs__panels {
  min-height: 100px;
}
</style>

##########
ui/Toast.vue
##########
<template>
  <!--
    Composant Toast - Notification temporaire

    Description : Notification avec auto-dismiss et icône

    Input (Props) :
      - isOpen : boolean (défaut: false) - Affichage
      - variant : 'success' | 'warning' | 'error' | 'info' (défaut: 'info')
      - title : string (requis) - Titre
      - duration : number (défaut: 3000) - Durée avant auto-dismiss (ms), 0 = infini
      - closable : boolean (défaut: true) - Affiche bouton fermer

    Output (Events) :
      - close : Émis lors de la fermeture

    Slots :
      - default : Contenu du message
  -->
  <Teleport to="body">
    <Transition name="toast-slide">
      <div v-if="isOpen" :class="toastClass" role="alert">
        <div class="toast__icon">{{ iconText }}</div>
        <div class="toast__content">
          <div class="toast__title">{{ title }}</div>
          <div v-if="$slots.default" class="toast__message">
            <slot />
          </div>
        </div>
        <button
          v-if="closable"
          class="toast__close"
          @click="handleClose"
          aria-label="Fermer"
        >
          ×
        </button>
      </div>
    </Transition>
  </Teleport>
</template>

<script setup lang="ts">
/**
 * TOAST COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .toast, .toast__icon, .toast__content, .toast--success
 * @dev Position fixed top-right
 * @dev Auto-dismiss avec setTimeout
 */

// Props
interface Props {
  isOpen?: boolean;
  variant?: 'success' | 'warning' | 'error' | 'info';
  title: string;
  duration?: number;
  closable?: boolean;
}

const props = withDefaults(defineProps<Props>(), {
  isOpen: false,
  variant: 'info',
  duration: 3000,
  closable: true,
});

// Events
interface Emits {
  close: [];
}

const emit = defineEmits<Emits>();

// Auto-dismiss timer
let autoCloseTimer: NodeJS.Timeout | null = null;

// Watch isOpen to manage auto-dismiss
watch(() => props.isOpen, (newValue) => {
  if (newValue && props.duration > 0) {
    // Clear existing timer
    if (autoCloseTimer) {
      clearTimeout(autoCloseTimer);
    }
    // Set new timer
    autoCloseTimer = setTimeout(() => {
      emit('close');
    }, props.duration);
  }
});

// Cleanup on unmount
onUnmounted(() => {
  if (autoCloseTimer) {
    clearTimeout(autoCloseTimer);
  }
});

// Computed class BEM
const toastClass = computed(() => {
  return [
    'toast',
    `toast--${props.variant}`,
  ].filter(Boolean).join(' ');
});

// Icon text based on variant
const iconText = computed(() => {
  const icons = {
    success: '✓',
    warning: '⚠',
    error: '✕',
    info: 'ℹ',
  };
  return icons[props.variant];
});

// Handle close
const handleClose = () => {
  if (autoCloseTimer) {
    clearTimeout(autoCloseTimer);
  }
  emit('close');
};
</script>

<style scoped>
/**
 * TOAST STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .toast */
.toast {
  position: fixed;
  top: var(--space-lg);
  right: var(--space-lg);
  z-index: 9999;
  display: flex;
  align-items: flex-start;
  gap: var(--space-sm);
  min-width: 300px;
  max-width: 400px;
  padding: var(--space-md);
  background-color: var(--bg-base);
  border-radius: var(--radius-md);
  box-shadow: var(--shadow-lg);
  border-left: 4px solid;
}

/* Variants */
.toast--success {
  border-left-color: var(--success);
}

.toast--warning {
  border-left-color: var(--warning);
}

.toast--error {
  border-left-color: var(--error);
}

.toast--info {
  border-left-color: var(--info);
}

/* Element : .toast__icon */
.toast__icon {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  border-radius: var(--radius-full);
  font-size: var(--text-base);
  font-weight: var(--font-bold);
  flex-shrink: 0;
  color: var(--text-inverse);
}

.toast--success .toast__icon {
  background-color: var(--success);
}

.toast--warning .toast__icon {
  background-color: var(--warning);
}

.toast--error .toast__icon {
  background-color: var(--error);
}

.toast--info .toast__icon {
  background-color: var(--info);
}

/* Element : .toast__content */
.toast__content {
  flex: 1;
  min-width: 0;
}

/* Element : .toast__title */
.toast__title {
  font-family: var(--font-sans);
  font-size: var(--text-base);
  font-weight: var(--font-semibold);
  color: var(--text-strong);
  margin-bottom: var(--space-xs);
}

/* Element : .toast__message */
.toast__message {
  font-family: var(--font-sans);
  font-size: var(--text-sm);
  color: var(--text-base);
  line-height: 1.5;
}

/* Element : .toast__close */
.toast__close {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 24px;
  height: 24px;
  padding: 0;
  background: none;
  border: none;
  font-size: 24px;
  line-height: 1;
  color: var(--text-base);
  cursor: pointer;
  flex-shrink: 0;
  transition: color 0.2s ease;
}

.toast__close:hover {
  color: var(--text-strong);
}

/* Transition : slide from right */
.toast-slide-enter-active,
.toast-slide-leave-active {
  transition: all 0.3s ease;
}

.toast-slide-enter-from {
  transform: translateX(100%);
  opacity: 0;
}

.toast-slide-leave-to {
  transform: translateX(100%);
  opacity: 0;
}
</style>

##########
ui/Tooltip.vue
##########
<template>
  <!--
    Composant Tooltip - Info-bulle contextuelle

    Description : Info-bulle avec positioning automatique

    Input (Props) :
      - text : string (requis) - Texte de la tooltip
      - position : 'top' | 'bottom' | 'left' | 'right' (défaut: 'top')
      - trigger : 'hover' | 'click' (défaut: 'hover')

    Output (Events) :
      Aucun

    Slots :
      - default : Élément déclencheur (requis)
  -->
  <div class="tooltip" ref="tooltipRef">
    <div
      class="tooltip__trigger"
      @mouseenter="handleMouseEnter"
      @mouseleave="handleMouseLeave"
      @click="handleClick"
    >
      <slot />
    </div>
    <Transition name="tooltip-fade">
      <div
        v-if="isVisible"
        :class="tooltipClass"
        role="tooltip"
      >
        {{ text }}
        <div class="tooltip__arrow"></div>
      </div>
    </Transition>
  </div>
</template>

<script setup lang="ts">
import { onClickOutside } from '@vueuse/core';

/**
 * TOOLTIP COMPONENT
 *
 * @dev CSS natif avec variables de _variables.css
 * @dev BEM strict : .tooltip, .tooltip__trigger, .tooltip__content, .tooltip--top
 * @dev Positioning automatique avec flèche directionnelle
 * @dev z-index élevé pour être au-dessus de tout
 */

// Props
interface Props {
  text: string;
  position?: 'top' | 'bottom' | 'left' | 'right';
  trigger?: 'hover' | 'click';
}

const props = withDefaults(defineProps<Props>(), {
  position: 'top',
  trigger: 'hover',
});

// State
const isVisible = ref(false);
const tooltipRef = ref<HTMLElement | null>(null);

// Computed class BEM
const tooltipClass = computed(() => {
  return [
    'tooltip__content',
    `tooltip__content--${props.position}`,
  ].filter(Boolean).join(' ');
});

// Handle mouse enter (hover trigger)
const handleMouseEnter = () => {
  if (props.trigger === 'hover') {
    isVisible.value = true;
  }
};

// Handle mouse leave (hover trigger)
const handleMouseLeave = () => {
  if (props.trigger === 'hover') {
    isVisible.value = false;
  }
};

// Handle click (click trigger)
const handleClick = () => {
  if (props.trigger === 'click') {
    isVisible.value = !isVisible.value;
  }
};

// Click outside to close (click trigger only)
onClickOutside(tooltipRef, () => {
  if (props.trigger === 'click') {
    isVisible.value = false;
  }
});
</script>

<style scoped>
/**
 * TOOLTIP STYLES - BEM strict
 *
 * @dev Variables de _variables.css
 */

/* Block : .tooltip */
.tooltip {
  position: relative;
  display: inline-block;
}

/* Element : .tooltip__trigger */
.tooltip__trigger {
  display: inline-block;
  cursor: help;
}

/* Element : .tooltip__content */
.tooltip__content {
  position: absolute;
  z-index: 10000;
  padding: var(--space-xs) var(--space-sm);
  background-color: var(--bg-elevated);
  color: var(--text-strong);
  font-family: var(--font-sans);
  font-size: var(--text-sm);
  line-height: 1.4;
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-lg);
  white-space: nowrap;
  max-width: 250px;
  word-wrap: break-word;
  white-space: normal;
  border: var(--border-width) solid var(--border-base);
}

/* Position : top */
.tooltip__content--top {
  bottom: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
}

.tooltip__content--top .tooltip__arrow {
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-top-color: var(--bg-elevated);
  border-bottom: none;
}

/* Position : bottom */
.tooltip__content--bottom {
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
}

.tooltip__content--bottom .tooltip__arrow {
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  border-bottom-color: var(--bg-elevated);
  border-top: none;
}

/* Position : left */
.tooltip__content--left {
  right: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
}

.tooltip__content--left .tooltip__arrow {
  left: 100%;
  top: 50%;
  transform: translateY(-50%);
  border-left-color: var(--bg-elevated);
  border-right: none;
}

/* Position : right */
.tooltip__content--right {
  left: calc(100% + 8px);
  top: 50%;
  transform: translateY(-50%);
}

.tooltip__content--right .tooltip__arrow {
  right: 100%;
  top: 50%;
  transform: translateY(-50%);
  border-right-color: var(--bg-elevated);
  border-left: none;
}

/* Element : .tooltip__arrow (flèche) */
.tooltip__arrow {
  position: absolute;
  width: 0;
  height: 0;
  border: 4px solid transparent;
}

/* Transition : fade */
.tooltip-fade-enter-active,
.tooltip-fade-leave-active {
  transition: opacity 0.2s ease;
}

.tooltip-fade-enter-from,
.tooltip-fade-leave-to {
  opacity: 0;
}
</style>



##########
app/composables/useThemeManager.ts
##########

/**
 * COMPOSABLE useThemeManager - PRD v2.0
 *
 * Gère le mode (light/dark) via @nuxtjs/color-mode
 * Gère les thèmes custom (default, ocean, sunset)
 *
 * @architecture SSOT (Single Source of Truth)
 * @module @nuxtjs/color-mode pour light/dark
 *
 * Phase 1 du PRD - Refonte Dark Mode
 */

export type ThemeName = 'default' | 'ocean' | 'sunset';
export type ColorModeValue = 'light' | 'dark' | 'system';

export const useThemeManager = () => {
  // @nuxtjs/color-mode gère automatiquement light/dark
  const colorMode = useColorMode();

  // State pour thème custom (default, ocean, sunset)
  const currentTheme = useState<ThemeName>('theme', () => 'default');

  /**
   * Change le mode light/dark
   * @param mode 'light' | 'dark' | 'system'
   */
  const setColorMode = (mode: ColorModeValue) => {
    colorMode.preference = mode;
  };

  /**
   * Change le thème de couleurs
   * @param theme 'default' | 'ocean' | 'sunset'
   */
  const setTheme = (theme: ThemeName) => {
    currentTheme.value = theme;
    if (process.client) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('swave-theme', theme);
    }
  };

  /**
   * Init thème au chargement (appelé via plugin)
   */
  const initTheme = () => {
    if (process.client) {
      const savedTheme = localStorage.getItem('swave-theme') as ThemeName | null;
      if (savedTheme && ['default', 'ocean', 'sunset'].includes(savedTheme)) {
        setTheme(savedTheme);
      } else {
        // Thème par défaut
        setTheme('default');
      }
    }
  };

  /**
   * Liste des thèmes disponibles
   */
  const availableThemes = [
    {
      value: 'default' as ThemeName,
      label: 'Default',
      description: 'Thème par défaut (Blue)',
    },
    {
      value: 'ocean' as ThemeName,
      label: 'Ocean',
      description: 'Thème bleu océan',
    },
    {
      value: 'sunset' as ThemeName,
      label: 'Sunset',
      description: 'Thème orange sunset',
    },
  ];

  return {
    // State (readonly)
    colorMode: readonly(computed(() => colorMode.value)),
    currentTheme: readonly(currentTheme),

    // Computed
    isDark: computed(() => colorMode.value === 'dark'),

    // Methods
    setColorMode,
    setTheme,
    initTheme,

    // Data
    availableThemes,
  };
};
